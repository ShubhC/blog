{
  
    
        "post0": {
            "title": "Why do competitors open their stores next to one another ?",
            "content": "A couple of days back, I was browsing YouTube and saw a Ted-Ed video in my recommendations. The title of the video was Why do competitors open their stores next to one another?. This is one of those questions which would occur in my mind from time to time but I never bothered to find an answer. There have been occasions when I had been driving for hours without seeing a petrol station, but when you spot one, you see a couple more clustered together as well. . Naturally, I watched the video and learnt that this can be explained using principles of game theory and Nash equilibrium. The video gave an interactive and simple explaination and you should definitely watch it - . . Now this video gave a great explaination but this time I wanted to see if we get the same results using data. . Disclaimer : I&#39;ve tried to list down all the assumptions that I have taken to model this problem. If you see things that are incorrect or incomplete, please let me know. . To start with let us create a city and lay out customers in it. . For this problem, I am creating a 1 x 1 grid representing a city and 1000 customers distributed uniformly in the grid. . customers = np.random.uniform(0, 1, (1000,2)) plt.scatter(customers[:,0], customers[:,1], c = &#39;lightgrey&#39;); . Now, let&#39;s add stores in the city. . We&#39;ll assume that the stores are initially randomly distributed and they are all attempting to reach to an optimal position in the city. We&#39;ll see the definition of an optimal position in later part of the post. . num_stores = 6 stores = np.random.uniform(0, 1., (num_stores,2)) . c = plt.scatter(customers[:,0], customers[:,1], c = &#39;lightgrey&#39;) s = plt.scatter(stores[:,0], stores[:,1], c = &#39;orange&#39;) plt.legend((c, s), (&#39;Customer&#39;, &#39;Store&#39;), scatterpoints=1, loc=&#39;lower left&#39;) plt.show() . Now that we have a basic problem set-up, let us try to come up with a criteria that a store would use to maximize its sales. To simplify the problem, we&#39;ll assume that all the stores are identical in liking and customers use distance as the only criteria to buy from a store. . In a setting when there is only one store in the city, the optimal position would be the one that minimizes the average distance customers have to travel to reach the store. Let us call this distance $d_{min}$. In case a second store comes up in the city, the optimal position for it would be to place itself in a way that it is as close as possible to $d_{min}$. The intuition behind this idea if the second store is too far, the customers are likely to visit the first store. . If we extend these ideas to a multi-store setting with $N$ customers, every store in the city would want to: . Be as closer as the nearest store to the customers i.e. minimize | . begin{equation} {minimize} frac{1}{N} sum_{i}^{N} frac{distance left ( customer_{i}, neareast { _} store_{i} right )}{distance left ( customer_{i}, store right )} end{equation} Minimize the average distance customers have to travel to reach the store | . begin{equation} {minimize} frac{1}{N} sum_{i}^{N}distance left ( customer_{i} - store right ) end{equation}Combining these two objectives, the overall objective for a store is to begin{equation} {minimize} left ( frac{1}{N} sum_{i}^{N} frac{distance left ( customer_{i}, neareast { _} store_{i} right )}{distance left ( customer_{i}, store right )} + frac{1}{N} sum_{i}^{N}distance left ( customer_{i} - store right ) right ) end{equation} . For the multi-store setting with $N$ customers and $M$ stores, the overall objective becomes begin{equation} {minimize} left ( frac{1}{M} sum_{j}^{M} left ( frac{1}{N} sum_{i}^{N} frac{distance left ( customer_{i}, neareast { _} store_{i} right )}{distance left ( customer_{i}, store_{j} right )} + frac{1}{N} sum_{i}^{N}distance left ( customer_{i} - store_{j} right ) right ) right ) end{equation} . Now that the entire problem had reduced to a minimization problem, we can use gradient descent to reach the optimal solution. . Let us start by creating store to customer distance vectors. For every store we&#39;ll calculate its distance from each customer. Thus for each store, we&#39;ll have $N$x$1$ vector. Since there are $M$ stores, the final output matrix would be of size $M$x$N$. . def calculate_store_to_customer_distances(stores, customers): res = (stores - customers)**2 res = res.sum(dim=2) res = torch.sqrt(res) return res . The objective function is our case becomes a loss function which we will backpropagate. . def loss_fn(stores, customers): store_customer_distance = calculate_store_to_customer_distances(stores, customers) # Be as closer as the nearest store min_store_customer_distance = store_customer_distance.min(0)[0] store_losses = 1. - ( min_store_customer_distance + 1e-7 ) / store_customer_distance store_losses = store_losses.sum(0).sum(0) total_store_customer_pairs = torch.numel(store_customer_distance) loss = store_losses / total_store_customer_pairs # minimize average distance customers have to travel to reach the store average_store_customer_distance = store_customer_distance.sum(0).sum(0) / total_store_customer_pairs loss += average_store_customer_distance return loss . Now that the data and the loss is defined, let us calcualte gradients and allow backpropagation to do its magic. . optimizer = torch.optim.SGD([stores], lr=1e-2) . for i in range(1,51): optimizer.zero_grad() loss = loss_fn(stores, customers) if i%10 == 0: print(&#39;At Epoch {0}, loss {1}&#39;.format(i, loss)) loss.backward() optimizer.step() with torch.no_grad(): stores[stores &lt; 0] = 0. stores[stores &gt; 1] = 1. . At Epoch 10, loss 0.40850992142825726 At Epoch 20, loss 0.3922313790948716 At Epoch 30, loss 0.39296911156435976 At Epoch 40, loss 0.3951459774244648 At Epoch 50, loss 0.39564915895903785 . Since the loss function doesn&#39;t seem to change a lot, let us see the current state of the stores in grid. . plt.scatter(customers[:,0], customers[:,1], c = &#39;lightgrey&#39;) t = stores.reshape(-1,2).detach().numpy() plt.scatter(t[:,0], t[:,1], c = &#39;orange&#39;) plt.show() . Voila! All the stores appear to be together. . They all seem to be around the mid-point of the city. Let&#39;s see their co-ordinates. . stores.reshape(num_stores,-1) . tensor([[0.4859, 0.5026], [0.4880, 0.5019], [0.4867, 0.5009], [0.4892, 0.5004], [0.4869, 0.5078], [0.4807, 0.5016]], dtype=torch.float64, grad_fn=&lt;ViewBackward&gt;) . All of them are around (0.5, 0.5) which seems sensible because their presence at mid-point would would offer equal reach in all the directions of a store. . So that’s it for today. . It was really fun for me to find out an answer for this problem and I hope that you enjoyed reading it. Feel free to post any questions and suggestions in the comment section. I will be happy to answer them. .",
            "url": "https://shubhc.github.io/blog/2021/08/08/Why-do-stores-open-next-to-each-other.html",
            "relUrl": "/2021/08/08/Why-do-stores-open-next-to-each-other.html",
            "date": " • Aug 8, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://shubhc.github.io/blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://shubhc.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://shubhc.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}